---
title: "STA240 Final Project"
format: pdf
author: "Anthony Zhao, Abby Li, William Yan"
execute: 
  echo: false
editor: 
  markdown: 
    wrap: 72
output: 
  pdf_document:
    latex_engine: xelatex
geometry: "top=2.5cm, bottom=2.5cm"
---

## Introduction

In 2024 alone, the restaurant industry was predicted to reach \$1
trillion in sales; however, with rising costs and increased competition,
owners must find innovative ways to keep up profit (National Restaurant
Association, 2024). With increased technology, many restaurants are
turning to data to provide insights into operations. Therefore, in this
project, we will be analyzing performance metrics in three different
scenarios to inform our decision on profit maximization. The goal for
this project is three-fold: to utilize probabilistic modeling to
optimize restaurant operations, to analyze customer behavior to maximize
consumer satisfaction, and to provide business recommendations by
considering key performance metrics such as waiting times, the number of
chefs, and more. In the following scenarios, we assume the restaurant
operates between the hours of 10am - 10pm.

## Scenario 1

The first scenario considers a setting with 1 table and 1 chef. Customer
arrival will be modeled to $W_k \sim Pois(\lambda)$ with $\lambda = 5$
and customer service time will be modeled by $S_k \sim Exp(\lambda)$
where $\lambda = 6$.

-   $T_k$: Arrival time of the $k$th customer

-   $W_k$: Time between the $k-1$th arrival and the $k$th arrival

$$
  W_k = T_k - T_{k-1}.
$$

```{r packages, message=F, warning=F}
library(tidyverse)
library(lubridate)
library(knitr)
library(dplyr)
library(gridExtra)
source("functions.R")

set.seed(121)

opening_time_s1 <- "10:00"
closing_time_s1 <- "22:00"
total_time_s1 <- calc_total_time(opening_time_s1, closing_time_s1)

arrival_rate_s1 <- 20 # customers per hour
arrival_times_s1 <- calc_simple_arrival_times(arrival_rate_s1, total_time_s1)

#arrival_times_s1

```

### Arrival Times

In this simulation, on average, the number of customers arriving is 5
per hour, so around every 12 minutes. The number of customers that will
be arriving within the operating hours is `r length(arrival_times_s1)`,
with the first customer arriving `r floor(min(arrival_times_s1))`
minutes after opening at 10:15 AM and the last customer arriving
`r ceiling(total_time_s1 - max(arrival_times_s1))` minutes before
closing at 8:54 PM.

```{r arrival-times}

# Start time as POSIXct
opening_time_s1 <- as.POSIXct("10:00", format = "%H:%M", tz = "UTC")

# Add minutes to the start time

time_of_day_s1 <- sapply(arrival_times_s1, function(m) {
  m <- round(m)  # Round to nearest whole number
  new_time <- opening_time_s1 + (m * 60)  # Add minutes converted to seconds
  format(new_time, "%H:%M")  # Format as "HH:MM"
})

#time_of_day_s1
```

```{r time-with-arrivals}

time_table <- data.frame(
  Minutes = arrival_times_s1,
  Time= time_of_day_s1
)

# head(time_table, 7)

```

```{r serving-times}
# given the output from above, simulate the serving times of customers before they leave

service_rate_s1 <- 6

service_times_s1 <- calc_simple_service_times(arrival_times_s1, service_rate_s1/3) # inside the function it gets multiplifed by 3

# service_rate_s1
```

```{r customer-service}

# determining waiting times

# for each observation (customer), calculate when the service begins and when it ends 
# serving ends = service begins + service time
# service begins: either when the customer walks in, or when the previous customer leaves (assumes there is a waiting time)

# compare this to the arrival time 
# if arrival time > time service ends then wait time = 0
# but if arrival time < service time ends then wait time = time service ends- arrival time 

# variable initialization
waiting_times_s1 <- numeric(length(arrival_times_s1))  # generating times for each customer
service_start <- numeric(length(arrival_times_s1)) 
service_end <- numeric(length(arrival_times_s1))  
current_end <- numeric(0) # service end time for current customer (i)

# iterate over each customer
for (i in 1:length(arrival_times_s1)) {

  # only includes observations where service time > arrival time => which means there is a wait time
  # gets rid of observations where service < arrival time => 0 wait time
  if (length(current_end) > 0) {
    current_end <- current_end[current_end > arrival_times_s1[i]]
  }
  
 if (length(current_end) == 0) {
   # scenario 1: if there is no waiting time, service starts at the customer arrival
    service_start[i] <- arrival_times_s1[i]
  } else {
    # scenario 2: if there is a waiting time, service starts at the end of the previous customer's end time
    previous_end <- service_end[i - 1]
    service_start[i] <- max(arrival_times_s1[i], previous_end)
  }
  
  # update the service end time for current customer by adding when service starts and how long the service takes
  service_end[i] <- service_start[i] + service_times_s1[i]
  
  # add this service end time to current end services
  current_end <- c(current_end , service_end[i])
  
  # update waiting time
  waiting_times_s1[i] <- service_start[i] - arrival_times_s1[i]
}

scen1_sim_results <- data.frame(
  Customer = 1:length(service_times_s1),
  Service_Length = service_times_s1,
  Service_Start = service_start,
  Service_End = service_end,
  Waiting_Time = waiting_times_s1,
  Time = time_of_day_s1,
  Arrival_time = arrival_times_s1
)

```

```{r service-times-graph, out.height= "30%"}

boxplot <- scen1_sim_results %>%
  ggplot(aes(x= Service_Length)) +
  geom_boxplot(width=0.5) +
  labs(
    x= "Minutes",
    title = "Service Times"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),    
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5) 
  )

boxplot

# grid.arrange(boxplot, widths = c(0.5))

summary_stats_service_times <- scen1_sim_results %>%
  summarize(
    Min = min(Service_Length),
    Q1 = quantile(Service_Length, 0.25),
    Median = median(Service_Length),
    Q3 = quantile(Service_Length, 0.75),
    Max = max(Service_Length),
  )

print(summary_stats_service_times)

```

The median service time is `r round(median(service_times_s1))` minutes,
with the shortest service time being `r round(min(service_times_s1))`
and the longest service time being `r round(max(service_times_s1))`,
which appears to be an outlier. Overall, the data is skewed right,
consistent with an exponential distribution, and this indicates that
service times tend to be quick.

```{r waiting-times-dist, out.height= "30%"}

boxplot2 <- scen1_sim_results %>%
  ggplot(aes(x= Waiting_Time)) +
  geom_boxplot() +
  labs(
    x= "Minutes",
    title = "Waiting Times"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

boxplot2

# grid.arrange(boxplot2, widths = c(0.5))

summary_stats_waiting_times <- scen1_sim_results %>%
  summarize(
    Min = min(Waiting_Time),
    Q1 = quantile(Waiting_Time, 0.25),
    Median = median(Waiting_Time),
    Q3 = quantile(Waiting_Time, 0.75),
    Max = max(Waiting_Time),
    SD = sd(Waiting_Time)
  )

print(summary_stats_waiting_times)

```

The median waiting time is `r round(median(waiting_times_s1))` minutes,
with the lowest waiting time being `r round(min(waiting_times_s1))` and
the highest waiting time being `r round(max(waiting_times_s1))`.
Overall, waiting times tends to be fairly symmetric with a slight
positive skew and there are no visible outliers. Wait times are spread
out with times being, on average, `r round(sd(waiting_times_s1))`
minutes from the mean of `r round(mean(waiting_times_s1))` minutes.

```{r info-together}
head(scen1_sim_results, 10)

#print(scen1_sim_results)
```

```{r, out.height= "30%"}

#Label for 30 min interval
breaks <- seq(0, 720, by = 60)

ggplot(scen1_sim_results, aes(x = Arrival_time, y = Waiting_Time)) +
  geom_point(color = "blue", size = 2, alpha = 0.6) +
    scale_x_continuous(
    breaks = breaks) +
  labs(
    title = "Waiting Time versus Time of Day",
    x = "Time of Day",
    y = "Waiting Time"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5) 
  )

```

Overall, waiting times appear to be highest around noon or lunch when
customer satisfication is lowest. Waiting times decrease steadily 3 pm
onwards until closing, suggesting a less busy dinner time where the
restaurant has more down time. In our simulation, the maximum service
time, 73 minutes, occured an hour before the rush hour, and as a result,
waiting times increased significantly after this customer. Although
overall service times are fairly quick, the restaurant should do their
best to ensure service times are just as fast or even faster during the
busy hours.

## Scenario 2

Assumptions:

1.  5 dining tables and L chefs with operating hours 10am - 10pm. We
    choose here that L = 2

2.  each table only seats one customer

3.  service time modeled by an exponential distribution with rate Î»S =
    3L, so that the more chefs there are, the faster the service times
    become

4.  24 customers arrive every hour

```{r arrival-service-2}

opening_time_s2 <- "10:00"
closing_time_s2 <- "22:00"
total_time_s2 <- calc_total_time(opening_time_s2, closing_time_s2)

arrival_rate_s2 <- 24 # customers per hour
arrival_times_s2 <- calc_simple_arrival_times(arrival_rate_s2, total_time_s2)

num_chefs_s2 <- 2 # we only have two chefs
service_times_s2 <- calc_simple_service_times(arrival_times_s2, num_chefs_s2)
```

### Waiting Times

To model waiting times, we iterate through the day minute by minute.

```{r waiting-2}

num_tables_s2 <- 5

sim_s2 <- restaurant_sim(arrival_times_s2, service_times_s2, num_tables_s2, total_time_s2)

scen2_sim_results_by_customer <- data.frame(
  customer = 1:length(arrival_times_s2),
  arrival_time = arrival_times_s2,
  service_length = service_times_s2,
  waiting_time = sim_s2$waiting_times
)

scen2_sim_results_by_minute <- data.frame(
  minutes_since_opening = 1:total_time_s2,
  queue_size = sim_s2$queue_size_history,
  occupied_tables = sim_s2$occupied_tables_history
)

```

```{r scenario-2-plots, echo=TRUE}

scen2_sim_results_by_customer |>
  ggplot(aes(x = arrival_time)) +
  geom_histogram(bins = 12, color = "black", fill = "white") +
  labs(
    x = "Arrival Time (Minutes after Opening)",
    y = "Count"
  ) +
  theme_minimal()

scen2_sim_results_by_customer |>
  ggplot(aes(x = service_length)) +
  geom_histogram(bins = 12, color = "black", fill = "white") +
  labs(
    x = "Service Duration (Minutes)",
    y = "Count"
  ) +
  theme_minimal()

scen2_sim_results_by_customer |>
  ggplot(aes(x = waiting_time)) +
  geom_histogram(bins = 12, color = "black", fill = "white") +
  labs(
    x = "Waiting Time (Minutes)",
    y = "Count"
  ) +
  theme_minimal()

scen2_sim_results_by_customer |>
  ggplot(aes(x = arrival_time, y = waiting_time)) +
  geom_point(size = 2, alpha = 0.6) +
  scale_x_continuous(breaks = seq(0, as.numeric(total_time_s2), by = 60)) +
  labs(
    x = "Minutes Since Opening",
    y = "Waiting time of Customer"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())


scen2_sim_results_by_minute |>
  ggplot(aes(x = minutes_since_opening, y = queue_size)) +
  geom_line() +
  scale_y_continuous(breaks = seq(1, max(sim_s2$queue_size_history), by = 1)) +
  scale_x_continuous(breaks = seq(0, as.numeric(total_time_s2), by = 60)) +
  labs(
    x = "Minutes Since Opening",
    y = "Queue Length"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())

# OCCUPIED TABLES
scen2_sim_results_by_minute |>
  ggplot(aes(x = minutes_since_opening, y = occupied_tables)) +
  geom_area(fill = "lightblue") +
  geom_line() +
  scale_y_continuous(breaks = seq(1, num_tables_s2, by = 1)) +
  scale_x_continuous(breaks = seq(0, as.numeric(total_time_s2), by = 60)) +
  labs(
    x = "Minutes Since Opening",
    y = "Number of Tables Occupied"
  ) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())

```

### Restaurant Profits

Assumptions:

1.  each customer spends \$50 per meal (customers who are still in the
    queue when the restaurant closes won't pay)

2.  each chef earns a wage of \$40 per hour (paid for the entire
    duration of the restaurant's operating hours)

3.  Each table cost \$1000 per day (extra service cost, rent, etc.)

4.  For customers who waited more than 30 minutes, they earn the
    restaurant half the amount of customers who didn't.

#### Maximizing Profits

With 5 tables, 24 customers arriving per hour, and these dollar amounts,
how many chefs should we hire? We will run our simulation 100 times with
1 to 5 chefs on staff, to see which will maximize the expected profit.

```{r}

df <- numeric(9)

for(b in 1:5) {
    num_chefs_s2 <- b
    for(i in 1:100) {
      arrival_times_s2 <- calc_simple_arrival_times(arrival_rate_s2, total_time_s2)
      service_times_s2 <- calc_simple_service_times(arrival_times_s2, num_chefs_s2)
      sim_s2 <- restaurant_sim(arrival_times_s2, service_times_s2, num_tables_s2, total_time_s2)
      df <- rbind(df, summarize_resturant_sim_s2(sim_s2$waiting_times, sim_s2$queue_size_history, sim_s2$occupied_tables_history, num_chefs_s2, total_time_s2, num_tables_s2))
    }
}

df <- df[-1, ]
df |> sample_n(8) # show 8 random rows
```

```{r}

df |>
  group_by(num_chefs) |>
  summarise(mean = mean(profit), sd = sd(profit)) |>
  ggplot(aes(x = num_chefs, y = mean)) +
  geom_bar(stat = "identity", fill = "darkgreen") +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2) +
  theme_bw() +
  labs(
    x = "Number of Chefs",
    y = "Average Profit"
  )

```

## Scenario 3

To make the simulation more realistic, we have a third scenario.

Assumptions: 1. Open at 10am, close at 10pm 2. From 12pm to 2pm and 6pm
to 8pm, 60 customers arrive every hour. Otherwise, 6 arrive every hour.
3. Instead of simulating service times with Exp(\lambda) where \lambda =
3 times the number of chefs, we do \lambda = ln(chefs + 1), so that
additional chefs beyond 2 make more of an impact. 4. Each customer will
sit for a minimum of 45 minutes. This flat value will be added to the
simulated service time, and is unaffected by staffing. 5. In the profit
calculation, there is a cost of adding additional tables (which are now
variable), which is \$40 per table. 6. Chefs still cost \$40 per hour to
hire, and each customer earns \$50.

### Arrival Times

```{r}

opening_time_s3 <- "10:00"
closing_time_s3 <- "22:00"
total_time_s3 <- calc_total_time(opening_time_s3, closing_time_s3)

arrival_times_s3 <- calc_realistic_arrival_times(
  open = "10:00",
  close = "22:00",
  lunch_peak_start = "12:00",
  lunch_peak_end = "14:00", 
  dinner_peak_start = "18:00",
  dinner_peak_end = "20:00", 
  lambda_down = 6, lambda_peak = 60)

ggplot(data = data.frame(arrival_times_s3), aes(x = arrival_times_s3)) +
  geom_histogram(binwidth = 10, fill = "blue", color = "black", alpha = 0.7) +
  labs(
    title = "Histogram of Customer Arrival Times",
    x = "Time of Day (Hours)",
    y = "Number of Arrivals"
  ) +
  scale_x_continuous(
    breaks = seq(0, 720, by = 60)
  ) +
  theme_minimal()
```

### Maximizing Profits

Under this scenario, how can we maximize profits?

```{r}

df <- numeric(9)
for(a in 1:5) {
  num_chefs_s3 = a
  for(b in seq(1, 101, by = 10)) {
    num_tables_s3 = b
    for(i in 1:20) {
      arrival_times_s3 <- calc_realistic_arrival_times(
        open = "10:00", close = "22:00",
        lunch_peak_start = "12:00",
        lunch_peak_end = "14:00", 
        dinner_peak_start = "18:00",
        dinner_peak_end = "20:00", 
        lambda_down = 6, lambda_peak = 60)
      service_times_s3 <- calc_realistic_service_times(arrival_times_s3, num_chefs_s3)
      sim_s3 <- restaurant_sim(arrival_times_s3, service_times_s3, num_tables_s3, total_time_s3)
      df <- rbind(df, summarize_resturant_sim_s3(sim_s3$waiting_times, sim_s3$queue_size_history, sim_s3$occupied_tables_history, num_chefs_s3, total_time_s3, num_tables_s3))
    }
  }
}

df <- df[-1, ]
```

```{r}
#Mean profit
df |>
  group_by(num_chefs, num_tables) |>
  summarise(mean = mean(profit), sd = sd(profit)) |>
  ggplot(aes(x = num_tables, y = num_chefs, fill = mean, text = sd)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "darkgreen") +
  scale_x_continuous(
    breaks = seq(min(df$num_tables), ceiling(max(df$num_tables)), by = 10),
    labels = seq(min(df$num_tables), ceiling(max(df$num_tables)), by = 10)  
  ) +
  scale_y_continuous(
    breaks = seq(min(df$num_chefs), ceiling(max(df$num_chefs)), by = 1),
    labels = seq(min(df$num_chefs), ceiling(max(df$num_chefs)), by = 1)  
  ) +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  labs(
    x = "Number of Tables",
    y = "Number of Chefs",
    color = "Average profit (dollars)",
    size = "SD between days"
  )
  
```

```{r}
# PROFIT
df |>
  group_by(num_chefs, num_tables) |>
  summarise(mean_profit = mean(profit), sd = sd(profit)) |>
  arrange(desc(mean_profit)) |>
  head(10)

# MEAN WAITING TIMES
df |>
  group_by(num_chefs, num_tables) |>
  summarise(profit = mean(profit), mean_waiting_time = mean(avg_waiting_time), sd = sd(avg_waiting_time)) |>
  arrange(desc(profit)) |>
  head(3)
  

# MEAN NUMBER OF PEOPLE WHO HAVE TO WAIT MORE THAN 30 MINUTES
df |>
  group_by(num_chefs, num_tables) |>
  summarise(profit = mean(profit), mean_long_waits = mean(long_waits), sd = sd(long_waits)) |>
  arrange(desc(profit)) |>
  head(3)

# MEAN QUEUE LENGTH
df |>
  group_by(num_chefs, num_tables) |>
  summarise(profit = mean(profit), mean_queue_length = mean(avg_queue_length), sd = sd(avg_queue_length)) |>
  arrange(desc(profit)) |>
  head(3)

# MEAN MAX QUEUE LENGTH FOR EACH DAY
df |>
  group_by(num_chefs, num_tables) |>
  summarise(profit = mean(profit), mean_max_queue = mean(max_queue_length), sd = sd(max_queue_length)) |>
  arrange(desc(profit)) |>
  head(3)

# MEAN TABLES OCCUPIED
df |>
  group_by(num_chefs, num_tables) |>
  summarise(profit = mean(profit), mean_occupied = mean(avg_tables_occupied), sd = sd(avg_tables_occupied)) |>
  arrange(desc(profit)) |>
  head(3)

```
